// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customer_profile.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomerProfile = `-- name: CreateCustomerProfile :one
INSERT INTO customer_profiles (user_id, contact_preference)
VALUES ($1, COALESCE($2, '{}'::JSONB))
RETURNING id, user_id, contact_preference
`

type CreateCustomerProfileParams struct {
	UserID  int32       `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) CreateCustomerProfile(ctx context.Context, arg CreateCustomerProfileParams) (CustomerProfile, error) {
	row := q.db.QueryRow(ctx, createCustomerProfile, arg.UserID, arg.Column2)
	var i CustomerProfile
	err := row.Scan(&i.ID, &i.UserID, &i.ContactPreference)
	return i, err
}

const deleteCustomerProfile = `-- name: DeleteCustomerProfile :exec
DELETE FROM customer_profiles WHERE user_id = $1
`

func (q *Queries) DeleteCustomerProfile(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteCustomerProfile, userID)
	return err
}

const getCustomerByUserID = `-- name: GetCustomerByUserID :one
SELECT 
  u.id AS user_id,
  u.first_name,
  u.last_name,
  u.email,
  u.phone_number,
  u.date_of_birth,
  u.is_active,
  u.created_at AS user_created_at,
  c.contact_preference
FROM users u
JOIN customer_profiles c ON u.id = c.user_id
WHERE u.id = $1
`

type GetCustomerByUserIDRow struct {
	UserID            int32            `json:"user_id"`
	FirstName         string           `json:"first_name"`
	LastName          pgtype.Text      `json:"last_name"`
	Email             string           `json:"email"`
	PhoneNumber       pgtype.Text      `json:"phone_number"`
	DateOfBirth       pgtype.Date      `json:"date_of_birth"`
	IsActive          pgtype.Bool      `json:"is_active"`
	UserCreatedAt     pgtype.Timestamp `json:"user_created_at"`
	ContactPreference []byte           `json:"contact_preference"`
}

func (q *Queries) GetCustomerByUserID(ctx context.Context, id int32) (GetCustomerByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByUserID, id)
	var i GetCustomerByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.IsActive,
		&i.UserCreatedAt,
		&i.ContactPreference,
	)
	return i, err
}

const getCustomerByUserIDLimited = `-- name: GetCustomerByUserIDLimited :one
SELECT 
  u.first_name,
  u.last_name,
  u.email
FROM users u
JOIN customer_profiles c ON u.id = c.user_id
WHERE u.id = $1
`

type GetCustomerByUserIDLimitedRow struct {
	FirstName string      `json:"first_name"`
	LastName  pgtype.Text `json:"last_name"`
	Email     string      `json:"email"`
}

func (q *Queries) GetCustomerByUserIDLimited(ctx context.Context, id int32) (GetCustomerByUserIDLimitedRow, error) {
	row := q.db.QueryRow(ctx, getCustomerByUserIDLimited, id)
	var i GetCustomerByUserIDLimitedRow
	err := row.Scan(&i.FirstName, &i.LastName, &i.Email)
	return i, err
}

const listCustomersPaginated = `-- name: ListCustomersPaginated :many
SELECT 
  u.id AS user_id,
  u.first_name,
  u.last_name,
  u.email,
  u.phone_number,
  u.date_of_birth,
  u.is_active,
  u.created_at AS user_created_at,
  c.contact_preference
FROM users u
JOIN customer_profiles c ON u.id = c.user_id
ORDER BY u.id DESC
LIMIT $1 OFFSET $2
`

type ListCustomersPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCustomersPaginatedRow struct {
	UserID            int32            `json:"user_id"`
	FirstName         string           `json:"first_name"`
	LastName          pgtype.Text      `json:"last_name"`
	Email             string           `json:"email"`
	PhoneNumber       pgtype.Text      `json:"phone_number"`
	DateOfBirth       pgtype.Date      `json:"date_of_birth"`
	IsActive          pgtype.Bool      `json:"is_active"`
	UserCreatedAt     pgtype.Timestamp `json:"user_created_at"`
	ContactPreference []byte           `json:"contact_preference"`
}

func (q *Queries) ListCustomersPaginated(ctx context.Context, arg ListCustomersPaginatedParams) ([]ListCustomersPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listCustomersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCustomersPaginatedRow{}
	for rows.Next() {
		var i ListCustomersPaginatedRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.IsActive,
			&i.UserCreatedAt,
			&i.ContactPreference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerProfile = `-- name: UpdateCustomerProfile :one
UPDATE customer_profiles
SET
  contact_preference = COALESCE($2, contact_preference)
WHERE user_id = $1
RETURNING id, user_id, contact_preference
`

type UpdateCustomerProfileParams struct {
	UserID            int32  `json:"user_id"`
	ContactPreference []byte `json:"contact_preference"`
}

func (q *Queries) UpdateCustomerProfile(ctx context.Context, arg UpdateCustomerProfileParams) (CustomerProfile, error) {
	row := q.db.QueryRow(ctx, updateCustomerProfile, arg.UserID, arg.ContactPreference)
	var i CustomerProfile
	err := row.Scan(&i.ID, &i.UserID, &i.ContactPreference)
	return i, err
}
